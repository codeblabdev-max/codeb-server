/**
 * CodeB Deploy MCP - 도메인 관리 도구
 * PowerDNS + Caddy 자동 설정
 */

import { getSSHClient } from '../lib/ssh-client.js';

interface DomainConfig {
  projectName: string;
  subdomain: string;        // e.g., 'myapp' → myapp.codeb.dev
  baseDomain: string;       // e.g., 'codeb.dev' 또는 'one-q.xyz'
  environment: 'staging' | 'production' | 'preview';
  targetPort: number;
  enableHttps?: boolean;
  enableWwwRedirect?: boolean;
}

interface DomainResult {
  success: boolean;
  domain: string;
  dnsRecordCreated: boolean;
  caddyConfigured: boolean;
  httpsEnabled: boolean;
  error?: string;
}

// 서버 IP (환경변수 또는 기본값)
const SERVER_IP = process.env.CODEB_SERVER_HOST || '141.164.60.51';

/**
 * PowerDNS에 A 레코드 추가
 */
async function addDnsRecord(
  subdomain: string,
  baseDomain: string,
  ip: string = SERVER_IP
): Promise<{ success: boolean; error?: string }> {
  const ssh = getSSHClient();
  const fullDomain = subdomain ? `${subdomain}.${baseDomain}` : baseDomain;

  try {
    // 레코드 존재 확인
    const checkResult = await ssh.exec(
      `pdnsutil list-zone ${baseDomain} 2>/dev/null | grep -E "^${fullDomain}\\s" || echo "NOT_FOUND"`
    );

    if (!checkResult.stdout.includes('NOT_FOUND')) {
      // 기존 레코드 삭제 후 재생성
      await ssh.exec(
        `pdnsutil delete-rrset ${baseDomain} ${fullDomain} A 2>/dev/null || true`
      );
    }

    // A 레코드 추가
    const addResult = await ssh.exec(
      `pdnsutil add-record ${baseDomain} ${subdomain || '@'} A 300 ${ip}`
    );

    if (addResult.code !== 0) {
      return { success: false, error: addResult.stderr };
    }

    // SOA 시리얼 증가 (변경 전파)
    await ssh.exec(`pdnsutil increase-serial ${baseDomain}`);

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Caddy 설정 생성 및 적용
 */
async function configureCaddy(config: {
  domain: string;
  targetPort: number;
  enableHttps: boolean;
  enableWwwRedirect: boolean;
  projectName: string;
  environment: string;
}): Promise<{ success: boolean; error?: string }> {
  const ssh = getSSHClient();
  const { domain, targetPort, enableHttps, enableWwwRedirect, projectName, environment } = config;

  try {
    // Caddy 설정 파일 내용 생성
    const caddyConfig = `
# ${projectName} - ${environment}
# Auto-generated by CodeB Deploy
${domain} {
    reverse_proxy localhost:${targetPort} {
        health_uri /api/health
        health_interval 30s
        health_timeout 10s
        fail_duration 30s
    }

    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        X-XSS-Protection "1; mode=block"
    }

    encode gzip zstd

    log {
        output file /var/log/caddy/${projectName}-${environment}.log {
            roll_size 10mb
            roll_keep 5
        }
    }
}
${enableWwwRedirect ? `
# Redirect www to main domain
www.${domain} {
    redir https://${domain}{uri} permanent
}
` : ''}
`;

    // Caddyfile.d 디렉토리에 개별 설정 파일 저장
    const configPath = `/etc/caddy/Caddyfile.d/${projectName}-${environment}.caddy`;

    // 디렉토리 확인 및 생성
    await ssh.exec('mkdir -p /etc/caddy/Caddyfile.d');

    // 설정 파일 쓰기
    await ssh.writeFile(configPath, caddyConfig);

    // Caddyfile에 import 구문 확인 및 추가
    const mainCaddyfile = await ssh.exec('cat /etc/caddy/Caddyfile');
    if (!mainCaddyfile.stdout.includes('import /etc/caddy/Caddyfile.d/*.caddy')) {
      // Caddyfile 끝에 import 추가
      await ssh.exec(`echo 'import /etc/caddy/Caddyfile.d/*.caddy' >> /etc/caddy/Caddyfile`);
    }

    // Caddy 설정 검증
    const validateResult = await ssh.exec('caddy validate --config /etc/caddy/Caddyfile');
    if (validateResult.code !== 0) {
      // 검증 실패 시 설정 파일 삭제
      await ssh.exec(`rm -f ${configPath}`);
      return { success: false, error: `Caddy validation failed: ${validateResult.stderr}` };
    }

    // Caddy 리로드
    const reloadResult = await ssh.exec('systemctl reload caddy');
    if (reloadResult.code !== 0) {
      return { success: false, error: `Caddy reload failed: ${reloadResult.stderr}` };
    }

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * 도메인 설정 (DNS + Caddy)
 */
export async function setupDomain(config: DomainConfig): Promise<DomainResult> {
  const ssh = getSSHClient();
  await ssh.connect();

  const {
    projectName,
    subdomain,
    baseDomain,
    environment,
    targetPort,
    enableHttps = true,
    enableWwwRedirect = false,
  } = config;

  const fullDomain = subdomain ? `${subdomain}.${baseDomain}` : baseDomain;

  try {
    // 1. DNS 레코드 추가
    const dnsResult = await addDnsRecord(subdomain, baseDomain);
    if (!dnsResult.success) {
      return {
        success: false,
        domain: fullDomain,
        dnsRecordCreated: false,
        caddyConfigured: false,
        httpsEnabled: false,
        error: `DNS setup failed: ${dnsResult.error}`,
      };
    }

    // 2. Caddy 설정
    const caddyResult = await configureCaddy({
      domain: fullDomain,
      targetPort,
      enableHttps,
      enableWwwRedirect,
      projectName,
      environment,
    });

    if (!caddyResult.success) {
      return {
        success: false,
        domain: fullDomain,
        dnsRecordCreated: true,
        caddyConfigured: false,
        httpsEnabled: false,
        error: `Caddy setup failed: ${caddyResult.error}`,
      };
    }

    // 3. DNS 전파 대기 (선택적)
    // await new Promise(resolve => setTimeout(resolve, 5000));

    return {
      success: true,
      domain: fullDomain,
      dnsRecordCreated: true,
      caddyConfigured: true,
      httpsEnabled: enableHttps,
    };

  } finally {
    ssh.disconnect();
  }
}

/**
 * 도메인 삭제 (DNS + Caddy)
 */
export async function removeDomain(config: {
  subdomain: string;
  baseDomain: string;
  projectName: string;
  environment: string;
}): Promise<{ success: boolean; error?: string }> {
  const ssh = getSSHClient();
  await ssh.connect();

  const { subdomain, baseDomain, projectName, environment } = config;
  const fullDomain = subdomain ? `${subdomain}.${baseDomain}` : baseDomain;

  try {
    // 1. Caddy 설정 삭제
    const configPath = `/etc/caddy/Caddyfile.d/${projectName}-${environment}.caddy`;
    await ssh.exec(`rm -f ${configPath}`);
    await ssh.exec('systemctl reload caddy');

    // 2. DNS 레코드 삭제
    await ssh.exec(`pdnsutil delete-rrset ${baseDomain} ${fullDomain} A 2>/dev/null || true`);
    await ssh.exec(`pdnsutil increase-serial ${baseDomain}`);

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  } finally {
    ssh.disconnect();
  }
}

/**
 * 프로젝트 도메인 일괄 설정 (staging + production)
 */
export async function setupProjectDomains(options: {
  projectName: string;
  baseDomain: string;
  stagingPort: number;
  productionPort: number;
  customStagingSubdomain?: string;
  customProductionSubdomain?: string;
}): Promise<{
  staging: DomainResult;
  production: DomainResult;
}> {
  const {
    projectName,
    baseDomain,
    stagingPort,
    productionPort,
    customStagingSubdomain,
    customProductionSubdomain,
  } = options;

  // Staging 도메인: projectname-staging.baseDomain
  const stagingSubdomain = customStagingSubdomain || `${projectName}-staging`;
  const stagingResult = await setupDomain({
    projectName,
    subdomain: stagingSubdomain,
    baseDomain,
    environment: 'staging',
    targetPort: stagingPort,
    enableHttps: true,
  });

  // Production 도메인: projectname.baseDomain
  const productionSubdomain = customProductionSubdomain || projectName;
  const productionResult = await setupDomain({
    projectName,
    subdomain: productionSubdomain,
    baseDomain,
    environment: 'production',
    targetPort: productionPort,
    enableHttps: true,
    enableWwwRedirect: true,
  });

  return {
    staging: stagingResult,
    production: productionResult,
  };
}

/**
 * Preview 환경 도메인 설정
 */
export async function setupPreviewDomain(options: {
  projectName: string;
  prNumber: string;
  baseDomain: string;
  targetPort: number;
}): Promise<DomainResult> {
  const { projectName, prNumber, baseDomain, targetPort } = options;

  // Preview 도메인: projectname-pr-123.preview.baseDomain
  const subdomain = `${projectName}-pr-${prNumber}.preview`;

  return setupDomain({
    projectName,
    subdomain,
    baseDomain,
    environment: 'preview',
    targetPort,
    enableHttps: true,
  });
}

/**
 * 도메인 상태 확인
 */
export async function checkDomainStatus(domain: string): Promise<{
  dnsResolved: boolean;
  httpsActive: boolean;
  httpResponse: number | null;
  error?: string;
}> {
  const ssh = getSSHClient();
  await ssh.connect();

  try {
    // DNS 확인
    const dnsCheck = await ssh.exec(`dig +short ${domain} A`);
    const dnsResolved = dnsCheck.stdout.trim().length > 0;

    // HTTP 확인
    const httpCheck = await ssh.exec(
      `curl -s -o /dev/null -w '%{http_code}' --max-time 10 https://${domain}/ 2>/dev/null || echo "000"`
    );
    const httpCode = parseInt(httpCheck.stdout.trim(), 10);
    const httpsActive = httpCode >= 200 && httpCode < 400;

    return {
      dnsResolved,
      httpsActive,
      httpResponse: httpCode || null,
    };
  } catch (error) {
    return {
      dnsResolved: false,
      httpsActive: false,
      httpResponse: null,
      error: error instanceof Error ? error.message : String(error),
    };
  } finally {
    ssh.disconnect();
  }
}
