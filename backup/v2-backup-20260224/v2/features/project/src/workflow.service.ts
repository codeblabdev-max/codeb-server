/**
 * WorkflowService - GitHub Actions workflow & Dockerfile template generation
 *
 * Refactored from mcp-server/src/tools/project.ts (workflowGenerateTool)
 */

import type { ProjectRepo } from '@codeb/db';
import type { AuthContext } from '@codeb/shared';

interface LoggerLike {
  info(message: string, meta?: Record<string, unknown>): void;
  error(message: string, meta?: Record<string, unknown>): void;
  warn(message: string, meta?: Record<string, unknown>): void;
  debug(message: string, meta?: Record<string, unknown>): void;
  log(level: string, message: string, meta?: Record<string, unknown>): void;
}

export interface WorkflowGenerateParams {
  projectName: string;
  baseDomain?: string;
  type?: 'nextjs' | 'remix' | 'nodejs' | 'python' | 'go';
  dockerfilePath?: string;
  buildContext?: string;
  paths?: string[];
}

export interface WorkflowGenerateResult {
  success: boolean;
  projectName: string;
  workflow: string;
  dockerfile: string;
  instructions: string[];
  error?: string;
}

export class WorkflowService {
  constructor(
    private readonly projectRepo: typeof ProjectRepo,
    private readonly logger: LoggerLike,
  ) {}

  async generate(
    params: WorkflowGenerateParams,
    auth: AuthContext,
  ): Promise<WorkflowGenerateResult> {
    const { projectName, baseDomain = 'codeb.kr', type = 'nextjs' } = params;

    try {
      const project = await this.projectRepo.findByName(projectName);
      if (!project) {
        return {
          success: false,
          projectName,
          workflow: '',
          dockerfile: '',
          instructions: [],
          error: `Project ${projectName} not found. Run project init first.`,
        };
      }

      const workflow = this.generateGitHubActionsWorkflow(projectName, type, baseDomain, {
        dockerfilePath: params.dockerfilePath,
        buildContext: params.buildContext,
        paths: params.paths,
      });
      const dockerfile = this.generateDockerfile(type);

      const instructions = [
        'Workflow generation complete!',
        '',
        'Local files to create:',
        '   1. .github/workflows/deploy.yml',
        '   2. Dockerfile (if missing)',
        '',
        'GitHub Secrets (Required):',
        '   - CODEB_API_KEY: CodeB MCP API key',
        '   - MINIO_ACCESS_KEY: Minio S3 access key (build cache)',
        '   - MINIO_SECRET_KEY: Minio S3 secret key (build cache)',
        '',
        'Deploy:',
        `   git push origin main  # -> Minio S3 cache build & Blue-Green deploy`,
        '',
        'Manual Actions:',
        `   promote:  gh workflow run deploy.yml -f action=promote`,
        `   rollback: gh workflow run deploy.yml -f action=rollback`,
      ];

      this.logger.info('Workflow generated', { projectName, type, baseDomain });

      return { success: true, projectName, workflow, dockerfile, instructions };
    } catch (error) {
      this.logger.error('Workflow generate failed', {
        projectName,
        error: error instanceof Error ? error.message : String(error),
      });
      return {
        success: false,
        projectName,
        workflow: '',
        dockerfile: '',
        instructions: [],
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  // ===========================================================================
  // Template Generators (public for reuse by InitService)
  // ===========================================================================

  generateGitHubActionsWorkflow(
    projectName: string,
    type: string,
    baseDomain: string = 'codeb.kr',
    options?: {
      dockerfilePath?: string;
      buildContext?: string;
      paths?: string[];
    },
  ): string {
    const dockerfilePath = options?.dockerfilePath || '.';
    const buildContext = options?.buildContext || '.';
    const pathsFilter = options?.paths?.length
      ? `\n    paths:\n${options.paths.map((p) => `      - '${p}'`).join('\n')}`
      : '';

    return `# ${projectName} CI/CD Pipeline (Minio S3 Cache + Blue-Green)
# Generated by CodeB v8.0
#
# Architecture:
#   GitHub Actions (self-hosted) -> Docker Buildx + Minio S3 Cache
#   -> Private Registry (64.176.226.119:5000) -> MCP API Blue-Green Deploy
#
# Required Secrets: CODEB_API_KEY, MINIO_ACCESS_KEY, MINIO_SECRET_KEY

name: ${projectName} CI/CD

on:
  push:
    branches: [main]${pathsFilter}
  workflow_dispatch:
    inputs:
      action:
        description: 'Action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - promote
          - rollback
      no_cache:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: 64.176.226.119:5000
  IMAGE_NAME: ${projectName}
  MINIO_ENDPOINT: http://64.176.226.119:9000
  MINIO_BUCKET: docker-cache

concurrency:
  group: ${projectName}-\${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================
  # Build & Deploy (push or dispatch deploy)
  # ============================================
  build-and-deploy:
    name: Build & Deploy
    runs-on: [self-hosted, codeb]
    if: github.event_name == 'push' || github.event.inputs.action == 'deploy'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: "Phase 1: MCP API Health Check"
        id: mcp_health
        timeout-minutes: 1
        run: |
          echo "=== Phase 1: MCP API 생존 확인 ==="

          HEALTH=\$(curl -sf --max-time 10 "https://api.codeb.kr/health") || true

          if [ -z "\$HEALTH" ]; then
            echo "CRITICAL: MCP API (api.codeb.kr) is DOWN"
            echo "Check: systemctl status codeb-mcp-api on 158.247.203.55"
            exit 1
          fi

          API_STATUS=\$(echo "\$HEALTH" | jq -r '.status // "unknown"')
          API_VERSION=\$(echo "\$HEALTH" | jq -r '.version // "unknown"')
          API_UPTIME=\$(echo "\$HEALTH" | jq -r '.uptime // 0' | xargs printf '%.0f')

          if [ "\$API_STATUS" != "healthy" ]; then
            echo "CRITICAL: MCP API status = \$API_STATUS (expected: healthy)"
            exit 1
          fi

          echo "MCP API: \$API_STATUS (v\$API_VERSION, uptime \${API_UPTIME}s)"

          # Version compatibility check (서버 SSOT)
          # 팀원 CLI/MCP 업데이트 안내용
          echo ""
          echo "=== Server Version (SSOT) ==="
          echo "API Server: v\$API_VERSION"
          echo ""
          echo "Team members: ensure CLI & MCP match server version."
          echo "  Check: we --version"
          echo "  Update: curl -sSL https://releases.codeb.kr/cli/install.sh | bash"
          echo ""

      - name: "Phase 2: Infrastructure Check (SSOT + Slot + Domain)"
        id: infra_check
        timeout-minutes: 2
        run: |
          echo "=== Phase 2: 프로젝트 인프라 확인 ==="

          # 2-1. SSOT 프로젝트 등록 확인
          SCAN=\$(curl -sf --max-time 30 -X POST "https://api.codeb.kr/api/tool" \\
            -H "X-API-Key: \${{ secrets.CODEB_API_KEY }}" \\
            -H "Content-Type: application/json" \\
            -d '{"tool": "scan", "params": {"projectName": "${projectName}"}}') || true

          if [ -z "\$SCAN" ] || [ "\$(echo "\$SCAN" | jq -r '.success // false')" != "true" ]; then
            echo "FAILED: Project '${projectName}' not registered in SSOT"
            echo "Fix: /we:init ${projectName}"
            exit 1
          fi

          REGISTERED=\$(echo "\$SCAN" | jq -r '.registered // false')
          HAS_ENV=\$(echo "\$SCAN" | jq -r '.hasEnv // false')
          ISSUES=\$(echo "\$SCAN" | jq -r '.issues | length // 0')

          if [ "\$REGISTERED" != "true" ]; then
            echo "FAILED: Project not registered. Issues:"
            echo "\$SCAN" | jq -r '.issues[]' 2>/dev/null
            echo "Fix: /we:init ${projectName}"
            exit 1
          fi
          echo "SSOT: registered"

          if [ "\$HAS_ENV" != "true" ]; then
            echo "WARNING: ENV file missing on app server"
          else
            echo "ENV: exists"
          fi

          # 2-2. Slot 레지스트리 상태 캡처 (배포 후 비교용)
          SLOT_BEFORE=\$(curl -sf --max-time 30 -X POST "https://api.codeb.kr/api/tool" \\
            -H "X-API-Key: \${{ secrets.CODEB_API_KEY }}" \\
            -H "Content-Type: application/json" \\
            -d '{"tool": "slot_status", "params": {"projectName": "${projectName}"}}') || true

          if [ -z "\$SLOT_BEFORE" ] || [ "\$(echo "\$SLOT_BEFORE" | jq -r '.success // false')" != "true" ]; then
            echo "FAILED: Slot registry not initialized for '${projectName}'"
            echo "Fix: /we:init ${projectName}"
            exit 1
          fi

          ACTIVE=\$(echo "\$SLOT_BEFORE" | jq -r '.data.activeSlot // "unknown"')
          BLUE_STATE=\$(echo "\$SLOT_BEFORE" | jq -r '.data.blue.state // "unknown"')
          GREEN_STATE=\$(echo "\$SLOT_BEFORE" | jq -r '.data.green.state // "unknown"')
          BLUE_PORT=\$(echo "\$SLOT_BEFORE" | jq -r '.data.blue.port // 0')
          GREEN_PORT=\$(echo "\$SLOT_BEFORE" | jq -r '.data.green.port // 0')

          echo "Slots: active=\$ACTIVE | blue=\$BLUE_STATE(:\$BLUE_PORT) | green=\$GREEN_STATE(:\$GREEN_PORT)"

          # Save for post-deploy comparison
          echo "\$SLOT_BEFORE" > /tmp/slot-before.json

          # 2-3. 도메인 DNS 확인
          DOMAIN_IP=\$(dig +short ${projectName}.${baseDomain} 2>/dev/null | head -1)
          if [ -z "\$DOMAIN_IP" ]; then
            echo "WARNING: ${projectName}.${baseDomain} DNS not resolving (may be propagating)"
          else
            echo "Domain: ${projectName}.${baseDomain} -> \$DOMAIN_IP"
          fi

          echo "=== Phase 2 passed ==="

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          config-inline: |
            [registry."64.176.226.119:5000"]
              http = true
              insecure = true

      - name: Build and Push (Minio S3 Cache)
        run: |
          IMAGE_TAG="\${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:\${{ github.sha }}"

          echo "Building: \$IMAGE_TAG"

          if [ "\${{ github.event.inputs.no_cache }}" = "true" ]; then
            echo "NO CACHE mode - forcing full rebuild"
            docker buildx build \\
              --no-cache \\
              -t "\$IMAGE_TAG" \\
              -t "\${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:latest" \\
              --push \\
              ${dockerfilePath !== '.' ? `-f ${dockerfilePath}/Dockerfile \\` : '\\'}
              ${buildContext}
          else
            docker buildx build \\
              --cache-from "type=s3,region=us-east-1,bucket=\${{ env.MINIO_BUCKET }},name=${projectName},endpoint_url=\${{ env.MINIO_ENDPOINT }},access_key_id=\${{ secrets.MINIO_ACCESS_KEY }},secret_access_key=\${{ secrets.MINIO_SECRET_KEY }}" \\
              --cache-to "type=s3,region=us-east-1,bucket=\${{ env.MINIO_BUCKET }},name=${projectName},mode=max,endpoint_url=\${{ env.MINIO_ENDPOINT }},access_key_id=\${{ secrets.MINIO_ACCESS_KEY }},secret_access_key=\${{ secrets.MINIO_SECRET_KEY }}" \\
              -t "\$IMAGE_TAG" \\
              -t "\${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:latest" \\
              --push \\
              ${dockerfilePath !== '.' ? `-f ${dockerfilePath}/Dockerfile \\` : '\\'}
              ${buildContext}
          fi

          echo "Built and pushed: \$IMAGE_TAG"

      - name: Deploy to inactive slot (Blue-Green)
        id: deploy
        timeout-minutes: 5
        run: |
          RESPONSE=\$(curl -sf --max-time 180 -X POST "https://api.codeb.kr/api/tool" \\
            -H "X-API-Key: \${{ secrets.CODEB_API_KEY }}" \\
            -H "Content-Type: application/json" \\
            -d '{
              "tool": "deploy",
              "params": {
                "projectName": "${projectName}",
                "environment": "production",
                "image": "\${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:\${{ github.sha }}"
              }
            }')

          echo "Response: \$RESPONSE"
          SUCCESS=\$(echo "\$RESPONSE" | jq -r '.success // false')
          if [ "\$SUCCESS" = "true" ]; then
            PREVIEW=\$(echo "\$RESPONSE" | jq -r '.previewUrl // "N/A"')
            SLOT=\$(echo "\$RESPONSE" | jq -r '.slot // "unknown"')
            PORT=\$(echo "\$RESPONSE" | jq -r '.port // 0')
            echo "Deployed to \$SLOT slot (port \$PORT)"
            echo "Preview: \$PREVIEW"

            # Save deploy result for Phase 3
            echo "\$RESPONSE" > /tmp/deploy-result.json
          else
            ERROR=\$(echo "\$RESPONSE" | jq -r '.error // "Unknown"')
            echo "Deploy failed: \$ERROR"
            exit 1
          fi

      - name: "Phase 3: Post-deploy Health Check & Verification"
        timeout-minutes: 3
        run: |
          echo "=== Phase 3: 배포 후 검증 ==="

          DEPLOY_RESULT=\$(cat /tmp/deploy-result.json 2>/dev/null)
          DEPLOYED_SLOT=\$(echo "\$DEPLOY_RESULT" | jq -r '.slot // "unknown"')
          PREVIEW_URL=\$(echo "\$DEPLOY_RESULT" | jq -r '.previewUrl // ""')

          # 3-1. Slot 상태 비교 (Before vs After)
          SLOT_AFTER=\$(curl -sf --max-time 30 -X POST "https://api.codeb.kr/api/tool" \\
            -H "X-API-Key: \${{ secrets.CODEB_API_KEY }}" \\
            -H "Content-Type: application/json" \\
            -d '{"tool": "slot_status", "params": {"projectName": "${projectName}"}}') || true

          if [ -n "\$SLOT_AFTER" ]; then
            AFTER_BLUE=\$(echo "\$SLOT_AFTER" | jq -r '.data.blue.state // "unknown"')
            AFTER_GREEN=\$(echo "\$SLOT_AFTER" | jq -r '.data.green.state // "unknown"')
            AFTER_BLUE_VER=\$(echo "\$SLOT_AFTER" | jq -r '.data.blue.version // "N/A"')
            AFTER_GREEN_VER=\$(echo "\$SLOT_AFTER" | jq -r '.data.green.version // "N/A"')

            # Before 상태 로드
            if [ -f /tmp/slot-before.json ]; then
              BEFORE_BLUE=\$(cat /tmp/slot-before.json | jq -r '.data.blue.state // "unknown"')
              BEFORE_GREEN=\$(cat /tmp/slot-before.json | jq -r '.data.green.state // "unknown"')
              echo "Slot changes:"
              echo "  blue:  \$BEFORE_BLUE -> \$AFTER_BLUE (version: \$AFTER_BLUE_VER)"
              echo "  green: \$BEFORE_GREEN -> \$AFTER_GREEN (version: \$AFTER_GREEN_VER)"
            else
              echo "Slot status: blue=\$AFTER_BLUE green=\$AFTER_GREEN"
            fi

            # 배포된 슬롯이 deployed 상태인지 확인
            if [ "\$DEPLOYED_SLOT" = "blue" ]; then
              DEPLOYED_STATE=\$AFTER_BLUE
            else
              DEPLOYED_STATE=\$AFTER_GREEN
            fi

            if [ "\$DEPLOYED_STATE" != "deployed" ] && [ "\$DEPLOYED_STATE" != "active" ]; then
              echo "WARNING: Deployed slot '\$DEPLOYED_SLOT' state is '\$DEPLOYED_STATE' (expected: deployed)"
            else
              echo "Slot verification: \$DEPLOYED_SLOT = \$DEPLOYED_STATE"
            fi
          fi

          # 3-2. Preview URL HTTP 헬스체크
          if [ -n "\$PREVIEW_URL" ] && [ "\$PREVIEW_URL" != "N/A" ] && [ "\$PREVIEW_URL" != "" ]; then
            echo "Checking preview URL: \$PREVIEW_URL"
            RETRIES=0
            MAX_RETRIES=6
            while [ \$RETRIES -lt \$MAX_RETRIES ]; do
              HTTP_CODE=\$(curl -sf -o /dev/null -w '%{http_code}' --max-time 10 "\$PREVIEW_URL" 2>/dev/null) || HTTP_CODE="000"
              if echo "\$HTTP_CODE" | grep -q "^[23]"; then
                echo "Preview healthy: HTTP \$HTTP_CODE"
                break
              fi
              RETRIES=\$((RETRIES + 1))
              if [ \$RETRIES -lt \$MAX_RETRIES ]; then
                echo "Preview not ready (HTTP \$HTTP_CODE), retry \$RETRIES/\$MAX_RETRIES in 10s..."
                sleep 10
              fi
            done

            if [ \$RETRIES -eq \$MAX_RETRIES ]; then
              echo "WARNING: Preview URL not responding after \$MAX_RETRIES retries (non-fatal)"
            fi
          fi

          # 3-3. GitHub Summary 작성
          echo "### Deployed" >> \$GITHUB_STEP_SUMMARY
          echo "| Key | Value |" >> \$GITHUB_STEP_SUMMARY
          echo "|-----|-------|" >> \$GITHUB_STEP_SUMMARY
          echo "| **Slot** | \\\`\$DEPLOYED_SLOT\\\` |" >> \$GITHUB_STEP_SUMMARY
          echo "| **Preview** | \$PREVIEW_URL |" >> \$GITHUB_STEP_SUMMARY
          if [ -n "\$SLOT_AFTER" ]; then
            echo "| **Blue** | \$AFTER_BLUE (\$AFTER_BLUE_VER) |" >> \$GITHUB_STEP_SUMMARY
            echo "| **Green** | \$AFTER_GREEN (\$AFTER_GREEN_VER) |" >> \$GITHUB_STEP_SUMMARY
          fi
          echo "" >> \$GITHUB_STEP_SUMMARY
          echo "> Run \\\`/we:promote ${projectName}\\\` or dispatch promote to switch traffic" >> \$GITHUB_STEP_SUMMARY

          echo "=== Phase 3 passed ==="

      - name: Cleanup
        if: always()
        run: |
          docker image prune -f 2>/dev/null || true
          rm -f /tmp/slot-before.json /tmp/deploy-result.json 2>/dev/null || true

  # ============================================
  # Promote (switch traffic)
  # ============================================
  promote:
    name: Promote (Switch Traffic)
    runs-on: [self-hosted, codeb]
    if: github.event.inputs.action == 'promote'

    steps:
      - name: Promote via MCP API
        timeout-minutes: 2
        run: |
          RESPONSE=\$(curl -sf --max-time 60 -X POST "https://api.codeb.kr/api/tool" \\
            -H "X-API-Key: \${{ secrets.CODEB_API_KEY }}" \\
            -H "Content-Type: application/json" \\
            -d '{
              "tool": "slot_promote",
              "params": {
                "projectName": "${projectName}",
                "environment": "production"
              }
            }')

          echo "Response: \$RESPONSE"
          SUCCESS=\$(echo "\$RESPONSE" | jq -r '.success // false')
          if [ "\$SUCCESS" = "true" ]; then
            echo "Traffic switched!"
            echo "### Promoted" >> \$GITHUB_STEP_SUMMARY
            echo "Production URL: https://${projectName}.${baseDomain}" >> \$GITHUB_STEP_SUMMARY
          else
            echo "Promote failed"
            exit 1
          fi

  # ============================================
  # Rollback (instant)
  # ============================================
  rollback:
    name: Rollback
    runs-on: [self-hosted, codeb]
    if: github.event.inputs.action == 'rollback'

    steps:
      - name: Rollback via MCP API
        timeout-minutes: 2
        run: |
          RESPONSE=\$(curl -sf --max-time 60 -X POST "https://api.codeb.kr/api/tool" \\
            -H "X-API-Key: \${{ secrets.CODEB_API_KEY }}" \\
            -H "Content-Type: application/json" \\
            -d '{
              "tool": "rollback",
              "params": {
                "projectName": "${projectName}",
                "environment": "production"
              }
            }')

          echo "Response: \$RESPONSE"
          SUCCESS=\$(echo "\$RESPONSE" | jq -r '.success // false')
          if [ "\$SUCCESS" = "true" ]; then
            echo "Rolled back!"
            echo "### Rolled Back" >> \$GITHUB_STEP_SUMMARY
            echo "Production URL: https://${projectName}.${baseDomain}" >> \$GITHUB_STEP_SUMMARY
          else
            echo "Rollback failed"
            exit 1
          fi
`;
  }

  generateDockerfile(type: string): string {
    const templates: Record<string, string> = {
      nextjs: `# CodeB v8.0 - Next.js Dockerfile
FROM node:20-alpine AS base

FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package*.json ./
RUN npm ci

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM base AS runner
WORKDIR /app
ENV NODE_ENV=production
ENV PORT=3000
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
USER nextjs
EXPOSE 3000
CMD ["node", "server.js"]
`,
      remix: `# CodeB v8.0 - Remix Dockerfile
FROM node:20-alpine AS base
FROM base AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build
FROM base AS runner
WORKDIR /app
ENV NODE_ENV=production
ENV PORT=3000
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/build ./build
COPY --from=builder /app/public ./public
COPY package*.json ./
EXPOSE 3000
CMD ["npm", "start"]
`,
      nodejs: `# CodeB v8.0 - Node.js Dockerfile
FROM node:20-alpine
WORKDIR /app
ENV NODE_ENV=production
ENV PORT=3000
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["node", "index.js"]
`,
      python: `# CodeB v8.0 - Python Dockerfile
FROM python:3.11-slim
WORKDIR /app
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV PORT=3000
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 3000
CMD ["python", "app.py"]
`,
      go: `# CodeB v8.0 - Go Dockerfile
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o app .
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /app
COPY --from=builder /app/app .
ENV PORT=3000
EXPOSE 3000
CMD ["./app"]
`,
    };

    return templates[type] || templates.nodejs;
  }
}
