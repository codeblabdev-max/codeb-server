/**
 * Environment File Generator
 *
 * Generates environment files for server and local development
 * - Server ENV content (production/staging)
 * - Local ENV content (development)
 * - Storage/Streaming server configuration
 */

import { getCliVersion } from '../../lib/config.js';

// Server infrastructure configuration
const STORAGE_SERVER = {
  host: 'db.codeb.kr',
  ip: '64.176.226.119',
  postgresPort: 5432,
  redisPort: 6379
};

const STREAMING_SERVER = {
  host: 'ws.codeb.kr',
  ip: '141.164.42.213',
  port: 8000
};

/**
 * Generate server environment file content
 * Uses Storage server (db.codeb.kr) for centralized DB/Redis
 * @param {Object} config - Configuration
 * @returns {string} ENV file content
 */
export function generateServerEnvContent(config) {
  const {
    projectName,
    environment = 'production',
    port = 3000,
    database,
    redis,
    storage
  } = config;

  let content = `# ${projectName} - ${environment.charAt(0).toUpperCase() + environment.slice(1)} Environment
# Generated by CodeB CLI v${getCliVersion()}

NODE_ENV=${environment}
PORT=${port}
HOSTNAME=0.0.0.0
`;

  if (database) {
    content += `
# PostgreSQL (Storage server: ${STORAGE_SERVER.host})
DATABASE_URL=postgresql://${database.user}:${database.password}@${STORAGE_SERVER.host}:${STORAGE_SERVER.postgresPort}/${database.database}?schema=public
POSTGRES_HOST=${STORAGE_SERVER.host}
POSTGRES_PORT=${STORAGE_SERVER.postgresPort}
POSTGRES_USER=${database.user}
POSTGRES_PASSWORD=${database.password}
POSTGRES_DB=${database.database}
`;
  }

  if (redis) {
    content += `
# Redis (Storage server: ${STORAGE_SERVER.host})
REDIS_URL=redis://${STORAGE_SERVER.host}:${STORAGE_SERVER.redisPort}/${redis.db_index}
REDIS_HOST=${STORAGE_SERVER.host}
REDIS_PORT=${STORAGE_SERVER.redisPort}
REDIS_DB=${redis.db_index}
REDIS_PREFIX=${redis.prefix}

# Centrifugo (Streaming server: ${STREAMING_SERVER.host})
CENTRIFUGO_URL=wss://${STREAMING_SERVER.host}/connection/websocket
CENTRIFUGO_API_URL=http://${STREAMING_SERVER.host}:${STREAMING_SERVER.port}/api
CENTRIFUGO_API_KEY=pRMupNs6HlGp7G6xkPsAFrI8hN4g6U0G
CENTRIFUGO_SECRET=of0KuRFjjzhq5LlBURCuKqzTUAA08hwL
`;
  }

  if (storage) {
    content += `
# Storage
STORAGE_PATH=/data
UPLOAD_PATH=/data/uploads
CACHE_PATH=/data/cache
`;
  }

  return content;
}

/**
 * Generate local .env.local content for development
 * @param {Object} config - Configuration
 * @returns {string} ENV file content
 */
export function generateLocalEnvContent(config) {
  const {
    projectName,
    serverHost,
    database,
    redis,
    dbExternalPort = 5432,
    redisExternalPort = 6379
  } = config;

  let content = `# ${projectName} - Local Development Environment
# Generated by CodeB CLI v${getCliVersion()}
# WARNING: This connects to REAL server data!

NODE_ENV=development
PORT=3000
`;

  if (database && serverHost) {
    content += `
# PostgreSQL (external server port)
DATABASE_URL=postgresql://${database.user}:${database.password}@${serverHost}:${dbExternalPort}/${database.database}?schema=public
`;
  }

  if (redis && serverHost) {
    content += `
# Redis (external server port)
REDIS_URL=redis://${serverHost}:${redisExternalPort}/${redis.db_index}
REDIS_PREFIX=${redis.prefix}

# Centrifugo (realtime messaging - development)
CENTRIFUGO_URL=wss://ws.codeb.kr/connection/websocket
CENTRIFUGO_API_URL=http://ws.codeb.kr:8000/api
CENTRIFUGO_API_KEY=pRMupNs6HlGp7G6xkPsAFrI8hN4g6U0G
CENTRIFUGO_SECRET=of0KuRFjjzhq5LlBURCuKqzTUAA08hwL
`;
  }

  content += `
# Storage (local paths for development)
STORAGE_PATH=./data
UPLOAD_PATH=./data/uploads
CACHE_PATH=./data/cache
`;

  return content;
}

/**
 * Generate .env.example template file
 * @param {Object} config - Configuration
 * @returns {string} ENV template content
 */
export function generateEnvTemplate(config) {
  const {
    projectName,
    useDatabase = true,
    useRedis = true,
    useCentrifugo = false,
    dbPassword = 'postgres',
    environment = 'production',
    useSharedStorage = true  // Default: use Storage server
  } = config;

  const containerPrefix = environment === 'production' ? projectName : `${projectName}-${environment}`;

  let template = `# ${projectName} Environment Configuration
# Environment: ${environment}
# Generated by CodeB CLI v${getCliVersion()}

NODE_ENV=${environment}
PORT=3000
`;

  if (useDatabase) {
    if (useSharedStorage) {
      // Storage server (db.codeb.kr) - recommended
      template += `
# PostgreSQL (Storage server: ${STORAGE_SERVER.host})
DATABASE_URL=postgresql://postgres:${dbPassword}@${STORAGE_SERVER.host}:${STORAGE_SERVER.postgresPort}/${projectName}?schema=public
POSTGRES_USER=postgres
POSTGRES_PASSWORD=${dbPassword}
POSTGRES_DB=${projectName}
`;
    } else {
      // Local container (legacy)
      template += `
# PostgreSQL (local container - not recommended)
DATABASE_URL=postgresql://postgres:${dbPassword}@${containerPrefix}-postgres:5432/${projectName}?schema=public
POSTGRES_USER=postgres
POSTGRES_PASSWORD=${dbPassword}
POSTGRES_DB=${projectName}
`;
    }
  }

  if (useRedis) {
    if (useSharedStorage) {
      // Storage server (db.codeb.kr) - recommended
      template += `
# Redis (Storage server: ${STORAGE_SERVER.host})
REDIS_URL=redis://${STORAGE_SERVER.host}:${STORAGE_SERVER.redisPort}
REDIS_PREFIX=${projectName}:
`;
    } else {
      // Local container (legacy)
      template += `
# Redis (local container - not recommended)
REDIS_URL=redis://${containerPrefix}-redis:6379
`;
    }
  }

  if (useCentrifugo) {
    template += `
# Centrifugo (Streaming server: ${STREAMING_SERVER.host})
CENTRIFUGO_URL=wss://${STREAMING_SERVER.host}/connection/websocket
CENTRIFUGO_API_URL=http://${STREAMING_SERVER.host}:${STREAMING_SERVER.port}/api
CENTRIFUGO_API_KEY=your-api-key
CENTRIFUGO_SECRET=your-secret
`;
  }

  template += `
# Add your application-specific variables below
# API_KEY=
# SECRET_KEY=
`;

  return template;
}

/**
 * Generate local .env.local for development (connects to server DB)
 * This allows developers to test against the deployed database
 * Simpler version without provisioned credentials
 * @param {Object} config - Configuration
 * @returns {string} ENV file content
 */
export function generateLocalEnvForDev(config) {
  const {
    projectName,
    serverHost,
    useDatabase = true,
    useRedis = true,
    dbPassword = 'postgres',
    dbPort = 5432,
    redisPort = 6379
  } = config;

  const dbName = projectName.replace(/-/g, '_');

  let content = `# ${projectName} - Local Development Environment
# Generated by CodeB CLI v${getCliVersion()}
# This file connects your local dev to the SERVER database
# WARNING: This connects to REAL server data!

NODE_ENV=development
PORT=3000
`;

  if (useDatabase && serverHost) {
    content += `
# PostgreSQL (connects to server)
# Container internal: postgresql://postgres:***@${projectName}-postgres:5432/${dbName}
# External access (for local dev):
DATABASE_URL=postgresql://postgres:${dbPassword}@${serverHost}:${dbPort}/${dbName}?schema=public
`;
  }

  if (useRedis && serverHost) {
    content += `
# Redis (connects to server)
# Container internal: redis://${projectName}-redis:6379
# External access (for local dev):
REDIS_URL=redis://${serverHost}:${redisPort}
`;
  }

  content += `
# Add your application-specific variables below
# NEXT_PUBLIC_API_URL=http://localhost:3000/api
# AUTH_SECRET=your-secret-here

# To use LOCAL database instead:
# DATABASE_URL=postgresql://postgres:postgres@localhost:5432/${dbName}?schema=public
`;

  return content;
}

/**
 * Create server environment files via MCP
 * Falls back to SSH direct only when MCP is unavailable
 * Creates /opt/codeb/envs/{project}-{env}.env on the server
 * @param {Object} config - Configuration
 * @returns {Promise<boolean>} Success status
 */
export async function createServerEnvFiles(config) {
  const { mcpClient } = await import('../../lib/mcp-client.js');
  const chalk = (await import('chalk')).default;

  const {
    projectName,
    serverHost,
    serverUser = 'root',
    useDatabase = true,
    useRedis = true,
    dbPassword = 'postgres'
  } = config;

  const dbName = projectName.replace(/-/g, '_');

  // Generate env content
  const productionEnvVars = {
    NODE_ENV: 'production',
    PORT: '3000',
    HOSTNAME: '0.0.0.0'
  };

  const stagingEnvVars = {
    NODE_ENV: 'staging',
    PORT: '3000',
    HOSTNAME: '0.0.0.0'
  };

  if (useDatabase) {
    productionEnvVars.DATABASE_URL = `postgresql://postgres:${dbPassword}@${projectName}-postgres:5432/${dbName}?schema=public`;
    productionEnvVars.POSTGRES_USER = 'postgres';
    productionEnvVars.POSTGRES_PASSWORD = dbPassword;
    productionEnvVars.POSTGRES_DB = dbName;

    stagingEnvVars.DATABASE_URL = `postgresql://postgres:${dbPassword}@${projectName}-staging-postgres:5432/${dbName}?schema=public`;
    stagingEnvVars.POSTGRES_USER = 'postgres';
    stagingEnvVars.POSTGRES_PASSWORD = dbPassword;
    stagingEnvVars.POSTGRES_DB = dbName;
  }

  if (useRedis) {
    productionEnvVars.REDIS_URL = `redis://${projectName}-redis:6379`;
    stagingEnvVars.REDIS_URL = `redis://${projectName}-staging-redis:6379`;
  }

  // Try MCP first (preferred path)
  try {
    const isConnected = await mcpClient.ensureConnected();
    if (isConnected) {
      // Use MCP manage_env tool to set environment variables
      await mcpClient.callTool('manage_env', {
        action: 'set',
        projectName,
        environment: 'production',
        envFile: productionEnvVars
      });

      await mcpClient.callTool('manage_env', {
        action: 'set',
        projectName,
        environment: 'staging',
        envFile: stagingEnvVars
      });

      return true;
    }
  } catch (mcpError) {
    // MCP failed, will fall through to SSH fallback
    console.log(chalk.gray(`  MCP env management failed, using SSH fallback...`));
  }

  // SSH Fallback (only when MCP unavailable)
  const { execSync } = await import('child_process');

  // Ensure /opt/codeb/envs directory exists
  execSync(`ssh ${serverUser}@${serverHost} "mkdir -p /opt/codeb/envs"`, { timeout: 30000 });

  // Generate production env content
  const productionEnv = `# ${projectName} - Production Environment
# Generated by CodeB CLI v${getCliVersion()}
# Location: /opt/codeb/envs/${projectName}-production.env

NODE_ENV=production
PORT=3000
HOSTNAME=0.0.0.0
${useDatabase ? `
# PostgreSQL (uses container DNS name)
DATABASE_URL=postgresql://postgres:${dbPassword}@${projectName}-postgres:5432/${dbName}?schema=public
POSTGRES_USER=postgres
POSTGRES_PASSWORD=${dbPassword}
POSTGRES_DB=${dbName}
` : ''}
${useRedis ? `
# Redis (uses container DNS name)
REDIS_URL=redis://${projectName}-redis:6379
` : ''}
# Add application secrets below
# AUTH_SECRET=
# API_KEY=
`;

  // Generate staging env content
  const stagingEnv = `# ${projectName} - Staging Environment
# Generated by CodeB CLI v${getCliVersion()}
# Location: /opt/codeb/envs/${projectName}-staging.env

NODE_ENV=staging
PORT=3000
HOSTNAME=0.0.0.0
${useDatabase ? `
# PostgreSQL (uses container DNS name)
DATABASE_URL=postgresql://postgres:${dbPassword}@${projectName}-staging-postgres:5432/${dbName}?schema=public
POSTGRES_USER=postgres
POSTGRES_PASSWORD=${dbPassword}
POSTGRES_DB=${dbName}
` : ''}
${useRedis ? `
# Redis (uses container DNS name)
REDIS_URL=redis://${projectName}-staging-redis:6379
` : ''}
# Add application secrets below
# AUTH_SECRET=
# API_KEY=
`;

  // Write production env to server
  const productionPath = `/opt/codeb/envs/${projectName}-production.env`;
  execSync(`ssh ${serverUser}@${serverHost} "cat > ${productionPath} << 'EOFENV'
${productionEnv}
EOFENV"`, { timeout: 30000 });

  // Write staging env to server
  const stagingPath = `/opt/codeb/envs/${projectName}-staging.env`;
  execSync(`ssh ${serverUser}@${serverHost} "cat > ${stagingPath} << 'EOFENV'
${stagingEnv}
EOFENV"`, { timeout: 30000 });

  return true;
}

/**
 * Merge environment files - adds new variables without overwriting protected ones
 * Protected: DATABASE_URL, REDIS_URL, DIRECT_URL, POSTGRES_*, DB_*
 * @param {string} existingContent - Existing ENV content
 * @param {string} newContent - New ENV content to merge
 * @returns {string} Merged ENV content
 */
export function mergeEnvFiles(existingContent, newContent) {
  const protectedPrefixes = ['DATABASE_URL', 'REDIS_URL', 'DIRECT_URL', 'POSTGRES_', 'DB_'];

  // Parse existing env
  const existingVars = new Map();
  for (const line of existingContent.split('\n')) {
    const match = line.match(/^([A-Z_][A-Z0-9_]*)=/);
    if (match) {
      existingVars.set(match[1], line);
    }
  }

  // Parse new env and identify what to add
  const newVars = new Map();
  for (const line of newContent.split('\n')) {
    const match = line.match(/^([A-Z_][A-Z0-9_]*)=/);
    if (match) {
      const varName = match[1];
      // Check if protected
      const isProtected = protectedPrefixes.some(prefix => varName.startsWith(prefix));
      if (!isProtected || !existingVars.has(varName)) {
        newVars.set(varName, line);
      }
    }
  }

  // Build merged content
  const lines = existingContent.split('\n');
  const addedVars = [];

  // Add new variables that don't exist
  for (const [varName, line] of newVars) {
    if (!existingVars.has(varName)) {
      addedVars.push(line);
    }
  }

  if (addedVars.length > 0) {
    // Add new vars at the end with a comment
    lines.push('');
    lines.push('# Added by workflow init');
    lines.push(...addedVars);
  }

  return lines.join('\n');
}
