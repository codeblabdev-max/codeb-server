/**
 * we init - 현재 프로젝트에 CodeB 설정 설치
 *
 * 글로벌 설치(npm install -g)와 별도로, 각 프로젝트 폴더에
 * CLAUDE.md, slash commands, hooks를 설치합니다.
 */

import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { existsSync } from 'fs';
import chalk from 'chalk';
import ora from 'ora';
import inquirer from 'inquirer';
import { getCliVersion, getConfig, saveConfig } from '../lib/config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Package root (cli/src/commands -> cli)
const PACKAGE_ROOT = path.join(__dirname, '..', '..');

// Source directories
const COMMANDS_SOURCE = path.join(PACKAGE_ROOT, 'commands', 'we');
const RULES_SOURCE = path.join(PACKAGE_ROOT, 'rules');

/**
 * 프로젝트 이름 감지 (package.json에서)
 */
async function detectProjectName(projectPath) {
  const pkgPath = path.join(projectPath, 'package.json');
  if (existsSync(pkgPath)) {
    try {
      const content = await fs.readFile(pkgPath, 'utf-8');
      const pkg = JSON.parse(content);
      return pkg.name || path.basename(projectPath);
    } catch {
      return path.basename(projectPath);
    }
  }
  return path.basename(projectPath);
}

/**
 * CLAUDE.md 템플릿 생성
 */
function generateClaudeMd(projectName) {
  return `# CLAUDE.md - ${projectName} Project Rules

## Project Info

- **Name**: ${projectName}
- **Generated by**: CodeB CLI v${getCliVersion()}
- **Date**: ${new Date().toISOString().split('T')[0]}

## Critical Rules

### 1. NEVER Run Dangerous Commands Directly

\`\`\`bash
# 절대 금지 (Hooks가 차단함)
podman rm -f <container>       # 직접 컨테이너 삭제
podman volume rm <volume>      # 직접 볼륨 삭제
docker-compose down -v         # 볼륨 포함 삭제
rm -rf /opt/codeb/projects/*   # 프로젝트 폴더 삭제
\`\`\`

### 2. ALWAYS Use CLI Commands

\`\`\`bash
# 올바른 방법
we workflow init ${projectName}     # 프로젝트 초기화
we deploy ${projectName}            # 배포
we workflow stop ${projectName}     # 서비스 중지
we workflow scan ${projectName}     # 상태 확인
we ssot sync                        # 서버 데이터 동기화
\`\`\`

### 3. SSH Only to Allowed Servers

허용된 서버만 SSH 접속 가능:
- 158.247.203.55 (App - app.codeb.kr)
- 141.164.42.213 (Streaming - ws.codeb.kr)
- 64.176.226.119 (Storage - db.codeb.kr)
- 141.164.37.63 (Backup - backup.codeb.kr)

### 4. Environment File Protection

- NEVER overwrite existing .env files without backup
- Protected variables: DATABASE_URL, REDIS_URL, POSTGRES_*

---

## Server Infrastructure

### 서버 역할 및 IP 매핑

| 역할 | IP | 도메인 | 주요 서비스 |
|------|-----|--------|------------|
| **App** | 158.247.203.55 | app.codeb.kr | Next.js 앱, Dashboard, PowerDNS |
| **Streaming** | 141.164.42.213 | ws.codeb.kr | **Centrifugo** (WebSocket) |
| **Storage** | 64.176.226.119 | db.codeb.kr | PostgreSQL, Redis (공유) |
| **Backup** | 141.164.37.63 | backup.codeb.kr | 백업, 모니터링 |

### 네임서버 (PowerDNS)
- n1.codeb.kr → 158.247.203.55 (Primary NS)
- n2.codeb.kr → 158.247.203.55 (Secondary NS)

### 포트 할당 규칙

| 서비스 | 포트 | 서버 |
|--------|------|------|
| PostgreSQL | 5432 | Storage (db.codeb.kr) |
| Redis | 6379 | Storage (db.codeb.kr) |
| Centrifugo | 8000 | Streaming (ws.codeb.kr) |
| 프로덕션 앱 | 4000-4499 | App (app.codeb.kr) |
| 스테이징 앱 | 4500-4999 | App (app.codeb.kr) |
| 개발용 | 5000-5499 | 로컬 |

---

## Real-time Communication (WebSocket)

### ❌ NEVER Use Socket.IO

\`\`\`javascript
// 절대 금지 - Socket.IO 사용 금지
import { Server } from 'socket.io';
import { io } from 'socket.io-client';
\`\`\`

### ✅ ALWAYS Use Centrifugo

Centrifugo는 Go로 작성된 고성능 실시간 메시징 서버입니다.

**Centrifugo 서버 정보:**
- Host: \`ws.codeb.kr\` (141.164.42.213)
- Port: \`8000\`
- WebSocket: \`wss://ws.codeb.kr/connection/websocket\`
- HTTP API: \`http://ws.codeb.kr:8000/api\`

**클라이언트 연결 (JavaScript):**
\`\`\`javascript
import { Centrifuge } from 'centrifuge';

const centrifuge = new Centrifuge('wss://ws.codeb.kr/connection/websocket', {
  token: await getConnectionToken()  // JWT 토큰
});

// 채널 구독
const sub = centrifuge.newSubscription('chat:room123');
sub.on('publication', (ctx) => {
  console.log('메시지:', ctx.data);
});
sub.subscribe();

centrifuge.connect();
\`\`\`

**ENV 설정:**
\`\`\`bash
# Centrifugo 설정 (Socket.IO 대신 사용)
CENTRIFUGO_URL=wss://ws.codeb.kr/connection/websocket
CENTRIFUGO_API_URL=http://ws.codeb.kr:8000/api
CENTRIFUGO_API_KEY=your-api-key
CENTRIFUGO_SECRET=your-secret
\`\`\`

---

## Quick Reference

\`\`\`bash
# 프로젝트 초기화
we workflow init ${projectName} --type nextjs --database --redis

# 서버 상태 확인
we ssot status
we ssot projects
we workflow scan ${projectName}

# 배포
we deploy ${projectName} --environment staging

# 도메인 설정
we domain setup ${projectName}.codeb.kr --ssl
\`\`\`

## Permission Model

- **Admin**: SSH + deploy + server settings
- **Developer**: Git Push only → GitHub Actions → auto deploy
`;
}

/**
 * .claude/commands/we/ 폴더에 slash commands 설치
 */
async function installSlashCommands(projectPath, spinner) {
  const targetDir = path.join(projectPath, '.claude', 'commands', 'we');

  try {
    // Check source directory
    if (!existsSync(COMMANDS_SOURCE)) {
      spinner.warn('Slash commands 소스가 없습니다. 건너뜁니다.');
      return { installed: 0, skipped: 0 };
    }

    // Create target directory
    await fs.mkdir(targetDir, { recursive: true });

    // Copy command files
    const files = await fs.readdir(COMMANDS_SOURCE);
    const mdFiles = files.filter(f => f.endsWith('.md'));

    let installed = 0;
    let skipped = 0;

    for (const file of mdFiles) {
      const srcPath = path.join(COMMANDS_SOURCE, file);
      const destPath = path.join(targetDir, file);

      // Check if already exists and is identical
      if (existsSync(destPath)) {
        const srcContent = await fs.readFile(srcPath, 'utf-8');
        const destContent = await fs.readFile(destPath, 'utf-8');
        if (srcContent === destContent) {
          skipped++;
          continue;
        }
      }

      await fs.copyFile(srcPath, destPath);
      installed++;
    }

    return { installed, skipped, total: mdFiles.length };
  } catch (err) {
    spinner.fail(`Slash commands 설치 오류: ${err.message}`);
    return { installed: 0, skipped: 0, error: err.message };
  }
}

/**
 * .claude/hooks/ 폴더에 hooks 설치
 */
async function installHooks(projectPath, spinner) {
  const targetDir = path.join(projectPath, '.claude', 'hooks');

  try {
    await fs.mkdir(targetDir, { recursive: true });

    const preBashHook = `#!/usr/bin/env python3
"""
CodeB Pre-Bash Hook
Blocks dangerous commands to protect infrastructure.
"""

import sys
import re

BLOCKED_PATTERNS = [
    r'podman\\s+rm\\s+-f',
    r'docker\\s+rm\\s+-f',
    r'podman\\s+volume\\s+rm',
    r'docker\\s+volume\\s+rm',
    r'docker-compose\\s+down\\s+-v',
    r'podman-compose\\s+down\\s+-v',
    r'rm\\s+-rf\\s+/opt/codeb',
    r'DROP\\s+DATABASE',
    r'DROP\\s+TABLE',
]

def check_command(cmd):
    for pattern in BLOCKED_PATTERNS:
        if re.search(pattern, cmd, re.IGNORECASE):
            return False, f"Blocked: matches pattern '{pattern}'"
    return True, None

if __name__ == '__main__':
    if len(sys.argv) < 2:
        sys.exit(0)
    cmd = ' '.join(sys.argv[1:])
    allowed, reason = check_command(cmd)
    if not allowed:
        print(f"Command blocked by CodeB hook: {reason}", file=sys.stderr)
        print(f"Use 'we' CLI commands instead.", file=sys.stderr)
        sys.exit(1)
    sys.exit(0)
`;

    const hookPath = path.join(targetDir, 'pre-bash.py');

    if (existsSync(hookPath)) {
      return { installed: 0, skipped: 1 };
    }

    await fs.writeFile(hookPath, preBashHook);
    await fs.chmod(hookPath, 0o755);

    return { installed: 1, skipped: 0 };
  } catch (err) {
    return { installed: 0, skipped: 0, error: err.message };
  }
}

/**
 * .claude/settings.local.json 생성 (프로젝트별 설정)
 */
async function installSettings(projectPath, spinner) {
  const settingsPath = path.join(projectPath, '.claude', 'settings.local.json');

  try {
    await fs.mkdir(path.join(projectPath, '.claude'), { recursive: true });

    if (existsSync(settingsPath)) {
      return { created: false, reason: 'already exists' };
    }

    const settings = {
      hooks: {
        PreBash: ["python3 .claude/hooks/pre-bash.py \"$BASH_COMMAND\""]
      }
    };

    await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2));
    return { created: true };
  } catch (err) {
    return { created: false, error: err.message };
  }
}

/**
 * API 키 검증
 */
async function validateApiKey(apiKey) {
  if (!apiKey) return false;

  try {
    const response = await fetch('https://api.codeb.kr/health', {
      headers: { 'X-API-Key': apiKey }
    });
    return response.ok;
  } catch {
    return false;
  }
}

/**
 * API 키 설정 확인 및 저장
 * @param {string} providedApiKey - 명령줄로 제공된 API 키 (옵션)
 */
async function ensureApiKey(providedApiKey) {
  const config = getConfig();

  // 1. 명령줄로 API 키가 제공된 경우
  if (providedApiKey) {
    if (!providedApiKey.startsWith('codeb_')) {
      console.log(chalk.red('\n❌ API 키는 "codeb_"로 시작해야 합니다.\n'));
      console.log(chalk.gray('형식: codeb_{teamId}_{role}_{token}'));
      console.log(chalk.gray('예시: codeb_myteam_member_abc123def456\n'));
      return { valid: false };
    }

    const spinner = ora('API 키 검증 중...').start();
    const isValid = await validateApiKey(providedApiKey);

    if (!isValid) {
      spinner.fail('API 키가 유효하지 않습니다.');
      console.log(chalk.red('\n팀 관리자에게 올바른 API 키를 요청하세요.\n'));
      return { valid: false };
    }

    spinner.succeed('API 키 검증 완료');

    // 설정 저장
    const newConfig = {
      ...config,
      CODEB_API_URL: 'https://api.codeb.kr',
      CODEB_API_KEY: providedApiKey
    };
    saveConfig(newConfig);
    console.log(chalk.green('✅ API 키가 ~/.codeb/config.json에 저장되었습니다.\n'));

    return { valid: true, apiKey: providedApiKey };
  }

  // 2. 저장된 API 키가 있고 유효한 경우
  if (config.CODEB_API_KEY) {
    const isValid = await validateApiKey(config.CODEB_API_KEY);
    if (isValid) {
      return { valid: true, apiKey: config.CODEB_API_KEY };
    }
    console.log(chalk.yellow('\n⚠️  저장된 API 키가 유효하지 않습니다.\n'));
  }

  // 3. API 키가 없거나 유효하지 않은 경우 - 사용법 안내
  console.log(chalk.cyan.bold('\n╔═══════════════════════════════════════════════════════════╗'));
  console.log(chalk.cyan.bold('║   CodeB API 키 설정 필요                                   ║'));
  console.log(chalk.cyan.bold('╚═══════════════════════════════════════════════════════════╝\n'));

  console.log(chalk.white('사용법:'));
  console.log(chalk.cyan('  we init <API_KEY>\n'));

  console.log(chalk.white('예시:'));
  console.log(chalk.gray('  we init codeb_myteam_member_abc123def456\n'));

  console.log(chalk.white('API 키 형식:'));
  console.log(chalk.gray('  codeb_{teamId}_{role}_{token}\n'));

  console.log(chalk.white('API 키 발급:'));
  console.log(chalk.gray('  팀 관리자(owner/admin)에게 요청하세요.\n'));

  return { valid: false };
}

/**
 * we init 명령어 핸들러
 * @param {string} apiKey - API 키 (옵션)
 * @param {object} options - 명령어 옵션
 */
export async function init(apiKey, options) {
  const projectPath = options.path || process.cwd();
  const projectName = await detectProjectName(projectPath);

  // 0. API 키 확인 (명령줄 인자로 받은 키 우선)
  const apiKeyResult = await ensureApiKey(apiKey);
  if (!apiKeyResult.valid) {
    process.exit(1);
  }

  console.log(chalk.cyan.bold('\n╔═══════════════════════════════════════════════════════════╗'));
  console.log(chalk.cyan.bold('║   CodeB Project Initialization                            ║'));
  console.log(chalk.cyan.bold('╚═══════════════════════════════════════════════════════════╝\n'));

  console.log(chalk.gray(`  Project: ${projectName}`));
  console.log(chalk.gray(`  Path:    ${projectPath}\n`));

  // 1. CLAUDE.md 설치 (rules/CLAUDE.md에서 복사) - 항상 백업 후 새로 생성
  const spinner1 = ora('CLAUDE.md 설치 중...').start();
  const claudeMdPath = path.join(projectPath, 'CLAUDE.md');
  const claudeMdSrc = path.join(RULES_SOURCE, 'CLAUDE.md');

  // 기존 파일이 있으면 무조건 백업
  if (existsSync(claudeMdPath)) {
    const backupPath = `${claudeMdPath}.backup.${Date.now()}`;
    await fs.copyFile(claudeMdPath, backupPath);
    spinner1.text = `기존 CLAUDE.md 백업 완료: ${path.basename(backupPath)}`;
  }

  // 항상 최신 버전으로 덮어쓰기
  if (existsSync(claudeMdSrc)) {
    await fs.copyFile(claudeMdSrc, claudeMdPath);
    spinner1.succeed('CLAUDE.md v7.0 설치 완료 (기존 파일 백업됨)');
  } else {
    // 소스 없으면 동적 생성
    const content = generateClaudeMd(projectName);
    await fs.writeFile(claudeMdPath, content);
    spinner1.succeed('CLAUDE.md 생성 완료 (템플릿)');
  }

  // 2. Slash Commands 설치
  const spinner2 = ora('Slash commands 설치 중...').start();
  const cmdResult = await installSlashCommands(projectPath, spinner2);
  if (cmdResult.installed > 0) {
    spinner2.succeed(`Slash commands: ${cmdResult.installed}개 설치 (.claude/commands/we/)`);
  } else if (cmdResult.skipped > 0) {
    spinner2.info(`Slash commands: ${cmdResult.skipped}개 이미 존재`);
  } else {
    spinner2.warn('Slash commands 소스 없음');
  }

  // 3. Hooks 설치
  const spinner3 = ora('Hooks 설치 중...').start();
  const hookResult = await installHooks(projectPath, spinner3);
  if (hookResult.installed > 0) {
    spinner3.succeed('pre-bash.py hook 설치 완료 (.claude/hooks/)');
  } else {
    spinner3.info('Hook이 이미 존재합니다');
  }

  // 4. Settings 설치
  const spinner4 = ora('Settings 구성 중...').start();
  const settingsResult = await installSettings(projectPath, spinner4);
  if (settingsResult.created) {
    spinner4.succeed('settings.local.json 생성 완료 (.claude/)');
  } else {
    spinner4.info('Settings가 이미 존재합니다');
  }

  // Summary
  console.log(chalk.cyan('\n═══════════════════════════════════════════════════════════'));
  console.log(chalk.green.bold('✅ 초기화 완료!\n'));

  console.log(chalk.white('생성된 파일:'));
  console.log(chalk.gray('  • CLAUDE.md                    - 프로젝트 규칙'));
  console.log(chalk.gray('  • .claude/commands/we/*.md     - Slash commands'));
  console.log(chalk.gray('  • .claude/hooks/pre-bash.py    - 위험 명령어 차단'));
  console.log(chalk.gray('  • .claude/settings.local.json  - Hook 설정'));

  console.log(chalk.cyan('\n다음 단계:'));
  console.log(chalk.white('  1. Claude Code 재시작 (변경사항 적용)'));
  console.log(chalk.white('  2. we workflow init ' + projectName + ' --type nextjs'));
  console.log(chalk.white('  3. we deploy ' + projectName + ' --environment staging'));

  console.log(chalk.cyan('\n═══════════════════════════════════════════════════════════\n'));
}
