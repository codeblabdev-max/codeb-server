/**
 * Quadlet Configuration Generator
 *
 * Generates Podman Quadlet files for systemd container management
 * Supports: App containers, PostgreSQL, Redis
 */

import { getCliVersion } from '../../lib/config.js';

/**
 * Generate Quadlet container configuration
 * @param {Object} config - Container configuration
 * @returns {string} Quadlet file content
 */
export function generateQuadletTemplate(config) {
  const {
    projectName,
    containerName,
    image,
    port,
    hostPort,
    environment = 'staging',
    envVars = {},
    envFile = null,  // External env file support
    volumes = [],
    dependencies = [],
    healthCheck = null,
    network = 'codeb-network',  // Default to codeb-network for DNS resolution
    memory = null,
    cpus = null
  } = config;

  // Build environment lines with systemd escaping
  const envLines = Object.entries(envVars)
    .map(([key, value]) => {
      // Escape special characters for systemd (! -> %%21, $ -> $$)
      const escapedValue = value.replace(/!/g, '%%21').replace(/\$/g, '$$');
      return `Environment=${key}=${escapedValue}`;
    })
    .join('\n');

  const volumeLines = volumes
    .map(v => `Volume=${v}`)
    .join('\n');

  const depServices = dependencies
    .map(d => `${d}.service`)
    .join(' ');

  // Resource limits for PodmanArgs
  const podmanArgs = [];
  if (memory) podmanArgs.push(`--memory=${memory}`);
  if (cpus) podmanArgs.push(`--cpus=${cpus}`);

  let template = `# ${projectName} - Quadlet Configuration
# Generated by CodeB CLI v${getCliVersion()}
# Environment: ${environment}
# Network: ${network} (DNS-based container communication)

[Unit]
Description=${projectName} ${environment} Container
After=network-online.target${dependencies.length ? ' ' + depServices : ''}
${dependencies.length ? `Requires=${depServices}` : ''}

[Container]
Image=${image}
ContainerName=${containerName}
PublishPort=${hostPort}:${port}
Network=${network}
${envLines}
${envFile ? `EnvironmentFile=${envFile}` : ''}
${volumeLines}
${healthCheck ? `HealthCmd=${healthCheck}` : ''}
${healthCheck ? `HealthInterval=30s` : ''}
${healthCheck ? `HealthTimeout=10s` : ''}
${healthCheck ? `HealthRetries=3` : ''}
${healthCheck ? `HealthStartPeriod=60s` : ''}
${podmanArgs.length ? `PodmanArgs=${podmanArgs.join(' ')}` : ''}

[Service]
Restart=always
RestartSec=10s
TimeoutStartSec=300

[Install]
WantedBy=multi-user.target default.target
`;

  // Clean up empty lines
  template = template.replace(/\n{3,}/g, '\n\n').replace(/\n\n\[/g, '\n\n[');

  return template.trim();
}

/**
 * Generate a complete project set (App + PostgreSQL + Redis)
 * @param {Object} config - Project configuration
 * @returns {Object} Quadlet files and metadata
 */
export function generateProjectSet(config) {
  const {
    projectName,
    environment = 'production',
    ports = { app: 3000, postgres: 5432, redis: 6379 },
    image,
    useDatabase = true,
    useRedis = true,
    network = 'codeb-network',
    dbPassword = 'postgres',
    dbUser = 'postgres',
    dbName = null,
    redisPassword = null
  } = config;

  const dbNameFinal = dbName || projectName.replace(/-/g, '_');
  const suffix = environment === 'production' ? '' : `-${environment}`;
  const containerPrefix = `${projectName}${suffix}`;

  const files = {};

  // 1. App Container (with DNS-based DATABASE_URL)
  const appEnvVars = {
    NODE_ENV: environment,
    PORT: '3000',
    HOSTNAME: '0.0.0.0'
  };

  if (useDatabase) {
    // Use container name for DNS resolution (no IP dependency!)
    appEnvVars.DATABASE_URL = `postgresql://${dbUser}:${dbPassword}@${containerPrefix}-postgres:5432/${dbNameFinal}?schema=public`;
  }

  if (useRedis) {
    const redisAuth = redisPassword ? `:${redisPassword}@` : '';
    appEnvVars.REDIS_URL = `redis://${redisAuth}${containerPrefix}-redis:6379`;
  }

  files[`${containerPrefix}.container`] = generateQuadletTemplate({
    projectName: `${projectName} App`,
    containerName: containerPrefix,
    image: image || `ghcr.io/codeb/${projectName}:latest`,
    port: 3000,
    hostPort: ports.app,
    environment,
    envVars: appEnvVars,
    envFile: `/etc/containers/systemd/${containerPrefix}.env`,
    dependencies: [
      ...(useDatabase ? [`${containerPrefix}-postgres`] : []),
      ...(useRedis ? [`${containerPrefix}-redis`] : [])
    ],
    healthCheck: 'curl -sf http://localhost:3000/api/health || exit 1',
    network,
    memory: environment === 'production' ? '2g' : '1g',
    cpus: environment === 'production' ? '2' : '1'
  });

  // 2. PostgreSQL Container
  if (useDatabase) {
    files[`${containerPrefix}-postgres.container`] = generateQuadletTemplate({
      projectName: `${projectName} PostgreSQL`,
      containerName: `${containerPrefix}-postgres`,
      image: 'docker.io/library/postgres:15-alpine',
      port: 5432,
      hostPort: ports.postgres,
      environment,
      envVars: {
        POSTGRES_USER: dbUser,
        POSTGRES_PASSWORD: dbPassword,
        POSTGRES_DB: dbNameFinal
      },
      volumes: [`${containerPrefix}-postgres-data:/var/lib/postgresql/data:Z`],
      healthCheck: `pg_isready -U ${dbUser}`,
      network
    });
  }

  // 3. Redis Container
  if (useRedis) {
    const redisEnvVars = {};

    files[`${containerPrefix}-redis.container`] = generateQuadletTemplate({
      projectName: `${projectName} Redis`,
      containerName: `${containerPrefix}-redis`,
      image: 'docker.io/library/redis:7-alpine',
      port: 6379,
      hostPort: ports.redis,
      environment,
      envVars: redisEnvVars,
      volumes: [`${containerPrefix}-redis-data:/data:Z`],
      healthCheck: 'redis-cli ping',
      network
    });
  }

  // Return structured result with metadata
  return {
    quadletFiles: files,
    containerPrefix,
    environment,
    envVars: {
      DATABASE_URL: useDatabase ? `postgresql://${dbUser}:${dbPassword}@${containerPrefix}-postgres:5432/${dbNameFinal}?schema=public` : null,
      REDIS_URL: useRedis ? `redis://${containerPrefix}-redis:6379` : null
    },
    services: {
      app: useDatabase || useRedis ? containerPrefix : projectName,
      postgres: useDatabase ? `${containerPrefix}-postgres` : null,
      redis: useRedis ? `${containerPrefix}-redis` : null
    }
  };
}
